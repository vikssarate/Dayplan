<script src="https://cdn.jsdelivr.net/npm/pouchdb@8.0.1/dist/pouchdb.min.js"></script>
<script>
(function(){
  const REMOTE = 'https://couch.techstudy.me/plan';
  const LOCAL_NAME = 'dayplan';
  const TZ = 'Asia/Kolkata';

  const db = new PouchDB(LOCAL_NAME);
  const remote = new PouchDB(REMOTE, { skip_setup:true });

  const listEl = document.getElementById('list');
  const addBtn = document.getElementById('addBtn');
  const syncBtn = document.getElementById('syncBtn');
  const pullBtn = document.getElementById('pullBtn');
  const syncStatus = document.getElementById('syncStatus');
  const countsEl = document.getElementById('counts');

  const uid = () => 'task:' + Math.random().toString(36).slice(2) + Date.now().toString(36);
  const emptyDays = () => [false,false,false,false,false,false,false];
  const debounce = (fn,ms=300)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }};

  function isoNow(){ return new Date().toISOString(); }

  // ---------- Editing guard (prevents rerender while typing) ----------
  let cache = [];
  let editingId = null;
  let isEditing = false;
  let pendingRerender = false;

  // track focus entering/leaving a row
  listEl.addEventListener('focusin', (e)=>{
    const row = e.target.closest('.row');
    if(row){ editingId = row.dataset.id; isEditing = true; }
  });
  // when focus truly leaves the edited row, allow a rerender
  listEl.addEventListener('focusout', (e)=>{
    setTimeout(()=>{
      const act = document.activeElement;
      const stillInside = act && act.closest && act.closest(`.row[data-id="${editingId}"]`);
      if(!stillInside){
        isEditing = false;
        editingId = null;
        if(pendingRerender){ pendingRerender = false; render(); }
      }
    }, 0);
  });

  // ---------- Rendering ----------
  function render(){
    // sort by time then name
    cache.sort((a,b)=>{
      const ta = a.time||'99:99', tb=b.time||'99:99';
      if(ta!==tb) return ta<tb?-1:1;
      return (a.title||'').localeCompare(b.title||'');
    });

    listEl.innerHTML = '';
    cache.forEach(doc=>{
      const row = document.createElement('div');
      row.className = 'grid row';
      row.dataset.id = doc._id;

      const title = document.createElement('input');
      title.type='text';
      title.placeholder='Task name';
      title.value = doc.title||'';
      title.oninput = onEdit;

      const time = document.createElement('input');
      time.type='time'; time.step=60;
      time.value = doc.time||'';
      time.oninput = onEdit;

      row.appendChild(title);
      row.appendChild(time);

      const d = doc.days || emptyDays();
      for(let i=0;i<7;i++){
        const cell = document.createElement('div');
        cell.className='daycell';
        const lab = document.createElement('label');
        const cb = document.createElement('input');
        cb.type='checkbox'; cb.checked = !!d[i];
        cb.onchange = onEdit;
        lab.appendChild(cb);
        cell.appendChild(lab);
        row.appendChild(cell);
      }

      const del = document.createElement('button');
      del.className='del'; del.title='Delete'; del.textContent='ðŸ—‘';
      del.onclick = async ()=>{
        try{ const fresh = await db.get(doc._id); await db.remove(fresh); }catch(e){ console.error(e); }
      };
      row.appendChild(del);

      row._inputs = {
        title,
        time,
        days: ()=> Array.from(row.querySelectorAll('input[type=checkbox]')).map(x=>x.checked)
      };

      if(!doc.title && !doc.time) row.classList.add('empty');
      listEl.appendChild(row);
    });

    countsEl.textContent = cache.length + (cache.length===1?' task':' tasks');
  }

  const saveDebounced = debounce(saveRow, 250);

  async function onEdit(ev){
    const row = ev.currentTarget.closest('.row');
    saveDebounced(row);
  }

  async function saveRow(row){
    const id = row.dataset.id;
    try{
      const fresh = await db.get(id);
      fresh.title = row._inputs.title.value.trim();
      fresh.time  = row._inputs.time.value;
      fresh.days  = row._inputs.days();
      fresh.tz    = TZ;
      fresh.updatedAt = isoNow();
      await db.put(fresh);
      // local cache update (optimistic) without re-render
      const i = cache.findIndex(x=>x._id===id);
      if(i>=0) cache[i] = {...fresh};
    }catch(e){ console.error(e); }
  }

  async function loadAll(){
    const res = await db.allDocs({include_docs:true, startkey:'task:', endkey:'task:\ufff0'});
    cache = res.rows.map(r=>r.doc);
    render();
  }

  // Live local changes â†’ update cache incrementally; render only if safe
  db.changes({since:'now', live:true, include_docs:true})
    .on('change', (c)=>{
      if(!c.doc || !c.id.startsWith('task:')) return;

      const i = cache.findIndex(x=>x._id===c.id);
      if(c.deleted){ if(i>=0) cache.splice(i,1); }
      else{ if(i>=0) cache[i]=c.doc; else cache.push(c.doc); }

      // If the changed doc is the one we are typing in, delay render
      if(isEditing && c.id===editingId){
        pendingRerender = true; // render after blur
      }else{
        render();
      }
    })
    .on('error', err=>console.error('changes error', err));

  // ---------- Add task ----------
  addBtn.onclick = async ()=>{
    const doc = {
      _id: uid(),
      type:'task',
      title:'',
      time:'',
      days: emptyDays(),
      tz: TZ,
      createdAt: isoNow(),
      updatedAt: isoNow()
    };
    await db.put(doc);
  };

  // ---------- Manual sync / pull ----------
  function setStatus(s){ syncStatus.textContent = 'Sync: ' + s; }

  syncBtn.onclick = async ()=>{
    setStatus('Manual syncâ€¦');
    try{ await db.replicate.to(remote); await db.replicate.from(remote); setStatus('Manual sync complete'); }
    catch(e){ console.error(e); setStatus('Manual sync error'); }
  };

  pullBtn.onclick = async ()=>{
    setStatus('Pullingâ€¦');
    try{ await db.replicate.from(remote); setStatus('Pulled'); }
    catch(e){ console.error(e); setStatus('Pull error'); }
  };

  // ---------- Live sync both ways ----------
  function startLiveSync(){
    const s = PouchDB.sync(db, remote, {live:true, retry:true});
    s.on('change', ()=> setStatus('changed'))
     .on('paused', err => setStatus(err ? 'paused (err)' : 'paused'))
     .on('active', ()=> setStatus('active'))
     .on('denied', ()=> setStatus('denied'))
     .on('complete', ()=> setStatus('complete'))
     .on('error', err => { console.error(err); setStatus('error'); });
  }

  // ---------- Visit heartbeat ----------
  async function recordVisit(){
    const id = 'app:state';
    try{
      let d; try{ d = await db.get(id); } catch{ d = {_id:id}; }
      d.lastVisitedAt = isoNow();
      await db.put(d);
    }catch(e){ console.error(e); }
  }

  // ---------- Boot ----------
  (async function boot(){
    await loadAll();
    try{ await db.replicate.from(remote); }catch(e){ console.warn('initial pull failed', e); }
    startLiveSync();
    recordVisit();
  })();

})();
</script>
